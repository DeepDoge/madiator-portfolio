<script lang="ts">
    import { onDestroy, onMount } from "svelte";

    /**
     * @license
     * Copyright 2015 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    export let center: boolean = false;
    export let disabled: boolean = false;
    let rippleElement: HTMLElement;

    const INITIAL_SCALE = "scale(0.0001, 0.0001)";
    const INITIAL_SIZE = "1px";
    const FINAL_SCALE = "";

    const IS_ANIMATING_CLASSNAME = "animating";
    const IS_VISIBLE_CLASSNAME = "visible";

    // Touch start produces a compat mouse down event, which would cause a
    // second ripples. To avoid that, we use this property to ignore the first
    // mouse down after a touch start.
    let ignoringMouseDown = false;

    let boundHeight = 0;
    let boundWidth = 0;

    let frameCount = 0;

    let rippleSize = 0;
    let rippleX = 0;
    let rippleY = 0;

    /**
     * Sets the ripple X and Y coordinates.
     * @param  {number} newX the new X coordinate
     * @param  {number} newY the new Y coordinate
     */
    const setRippleXY = function (newX, newY) {
        rippleX = newX;
        rippleY = newY;
    };

    /**
     * Sets the ripple styles.
     * @param  {boolean} start whether or not this is the start frame.
     */
    const setRippleStyles = function (start: boolean) {
        if (rippleElement !== null) {
            let transformString;
            let scale;
            let size;
            let offset = "translate(" + rippleX + "px, " + rippleY + "px)";
            if (start) {
                scale = INITIAL_SCALE;
                size = INITIAL_SIZE;
            } else {
                scale = FINAL_SCALE;
                size = rippleSize + "px";
                if (center) offset = "translate(" + boundWidth / 2 + "px, " + boundHeight / 2 + "px)";
            }
            transformString = "translate(-50%, -50%) " + offset + scale;
            rippleElement.style.transform = transformString;
            rippleElement.style.width = size;
            rippleElement.style.height = size;
            if (start) rippleElement?.classList.remove(IS_ANIMATING_CLASSNAME);
            else rippleElement?.classList.add(IS_ANIMATING_CLASSNAME);
        }
    };

    /**
     * Handles an animation frame.
     */
    const animFrameHandler = function () {
        if (frameCount-- > 0) {
            window.requestAnimationFrame(animFrameHandler.bind(this));
        } else {
            setRippleStyles(false);
        }
    };

    const downHandler = function (event) {
        if (!rippleElement.style.width && !rippleElement.style.height) {
            var rect = rippleElement.parentElement.getBoundingClientRect();
            boundHeight = rect.height;
            boundWidth = rect.width;
            rippleSize = Math.sqrt(rect.width * rect.width + rect.height * rect.height) * 2 + 2;
            rippleElement.style.width = rippleSize + "px";
            rippleElement.style.height = rippleSize + "px";
        }
        rippleElement?.classList.add(IS_VISIBLE_CLASSNAME);
        if (event.type === "mousedown" && ignoringMouseDown) {
            ignoringMouseDown = false;
        } else {
            if (event.type === "touchstart") {
                ignoringMouseDown = true;
            }
            if (frameCount > 0) return;
            frameCount = 1;
            var bound = event.currentTarget.getBoundingClientRect();
            var x;
            var y;
            // Check if we are handling a keyboard click.
            if (event.clientX === 0 && event.clientY === 0) {
                x = Math.round(bound.width / 2);
                y = Math.round(bound.height / 2);
            } else {
                var clientX = event.clientX !== undefined ? event.clientX : event.touches[0].clientX;
                var clientY = event.clientY !== undefined ? event.clientY : event.touches[0].clientY;
                x = Math.round(clientX - bound.left);
                y = Math.round(clientY - bound.top);
            }
            setRippleXY(x, y);
            setRippleStyles(true);
            window.requestAnimationFrame(animFrameHandler.bind(this));
        }
    };

    const upHandler = function (event) {
        // Don't fire for the artificial "mouseup" generated by a double-click.
        if (event && event.detail !== 2) {
            // Allow a repaint to occur before removing this class, so the animation
            // shows for tap events, which seem to trigger a mouseup too soon after
            // mousedown.
            setTimeout(
                function () {
                    rippleElement?.classList.remove(IS_VISIBLE_CLASSNAME);
                }.bind(this),
                0
            );
        }
    };

    let boundDownHandler = downHandler.bind(this);
    let boundUpHandler = upHandler.bind(this);

    onMount(() => {
        rippleElement.parentElement?.classList.add("__ripple-parent");
        rippleElement.parentElement.addEventListener("mousedown", boundDownHandler);
        rippleElement.parentElement.addEventListener("touchstart", boundDownHandler);

        rippleElement.parentElement.addEventListener("mouseup", boundUpHandler);
        rippleElement.parentElement.addEventListener("mouseleave", boundUpHandler);
        rippleElement.parentElement.addEventListener("touchend", boundUpHandler);
        rippleElement.parentElement.addEventListener("blur", boundUpHandler);
    });

    onDestroy(() => {
        if (!rippleElement) return;
        rippleElement.parentElement?.classList.remove("__ripple-parent");
        rippleElement.parentElement.removeEventListener("mousedown", boundDownHandler);
        rippleElement.parentElement.removeEventListener("touchstart", boundDownHandler);

        rippleElement.parentElement.removeEventListener("mouseup", boundUpHandler);
        rippleElement.parentElement.removeEventListener("mouseleave", boundUpHandler);
        rippleElement.parentElement.removeEventListener("touchend", boundUpHandler);
        rippleElement.parentElement.removeEventListener("blur", boundUpHandler);
    });
</script>

<div bind:this={rippleElement} class="ripple" class:disabled />
<div style="display: none;" class="ripple animating visible" />

<style>
    :global(.__ripple-parent) {
        position: relative;
        overflow: hidden;
    }

    .ripple {
        background: var(--g-text-color);
        border-radius: 50%;
        height: 100vh;
        left: 0;
        opacity: 0;
        pointer-events: none;
        position: absolute;
        top: 0;
        -webkit-transform: translate(-50%, -50%);
        transform: translate(-50%, -50%);
        width: 100vw;
        overflow: hidden;
    }

    .ripple.animating {
        transition: transform 0.3s cubic-bezier(0, 0, 0.2, 1), width 0.3s cubic-bezier(0, 0, 0.2, 1), height 0.3s cubic-bezier(0, 0, 0.2, 1),
            opacity 0.6s cubic-bezier(0, 0, 0.2, 1);
        transition: transform 0.3s cubic-bezier(0, 0, 0.2, 1), width 0.3s cubic-bezier(0, 0, 0.2, 1), height 0.3s cubic-bezier(0, 0, 0.2, 1),
            opacity 0.6s cubic-bezier(0, 0, 0.2, 1), -webkit-transform 0.3s cubic-bezier(0, 0, 0.2, 1);
    }

    .ripple.visible {
        opacity: 0.3;
    }

    .ripple.disabled {
        display: none;
    }
</style>
